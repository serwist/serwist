import { highlightCode } from "$lib/highlightCode";
import { encodeOpenGraphImage } from "$lib/og";
import type { PageServerLoad } from "./$types";

export const load: PageServerLoad = ({ locals }) => ({
  title: "Home",
  ogImage: encodeOpenGraphImage("Home"),
  code: {
    gettingStarted: highlightCode(
      locals.highlighter,
      {
        "sw.ts": {
          code: `import { Serwist } from "serwist";

const serwist = new Serwist({
  precacheEntries: self.__SW_MANIFEST,
  skipWaiting: true,
  clientsClaim: true,
});

serwist.addEventListeners();`,
          lang: "typescript",
        },
        "build.ts": {
          code: `import { injectManifest } from "@serwist/build";

injectManifest({
  swSrc: "app/sw.ts",
  swDest: "dist/sw.js",
  globDirectory: "dist/static",
});`,
          lang: "typescript",
        },
      },
      { idPrefix: "getting-started", useTwoslash: false },
    ),
    customizing: highlightCode(
      locals.highlighter,
      {
        "sw.ts": {
          code: `import type { PrecacheEntry, SerwistGlobalConfig } from "serwist";
import { Serwist } from "serwist";
import { defaultCache } from "@serwist/vite/worker";

declare global {
  interface WorkerGlobalScope extends SerwistGlobalConfig {
    // Change this attribute's name to your \`injectionPoint\`.
    // \`injectionPoint\` is an InjectManifest option.
    // See https://serwist.pages.dev/docs/build/inject-manifest/configuring
    __SW_MANIFEST: (PrecacheEntry | string)[] | undefined;
  }
}

declare const self: ServiceWorkerGlobalScope;

const serwist = new Serwist({
  // A list of URLs that should be cached. Usually, you don't generate
  // this list yourself; rather, you'd rely on a Serwist build tool/your framework
  // to do it for you. In this example, it is generated by \`@serwist/vite\`.
  precacheEntries: self.__SW_MANIFEST,
  // Options to customize how Serwist precaches the URLs.
  precacheOptions: {
    // Whether outdated caches should be removed.
    cleanupOutdatedCaches: true,
    concurrency: 10,
    ignoreURLParametersMatching: [],
  },
  // Whether the service worker should skip waiting and become the active one.
  skipWaiting: true,
  // Whether the service worker should claim any currently available clients.
  clientsClaim: true,
  // Whether navigation preloading should be used.
  navigationPreload: false,
  // Whether Serwist should log in development mode.
  disableDevLogs: true,
  // A list of runtime caching entries. When a request is made and its URL match
  // any of the entries, the response to it will be cached according to the matching
  // entry's \`handler\`. This does not apply to precached URLs.
  runtimeCaching: defaultCache,
  // Other options...
  // See https://serwist.pages.dev/docs/serwist/core/serwist
});

serwist.addEventListeners();`,
          lang: "typescript",
        },
        "build.ts": {
          code: `import { injectManifest, type ManifestTransform } from "@serwist/build";

/**
 * A custom build ID.
 */
declare const BUILD_ID: string;
/**
 * Hash a file based on its contents.
 */
declare const hashFile: (file: string) => string;
/**
 * Whether the server is currently in development mode.
 */
declare const dev: boolean;

const manifestTransform: ManifestTransform = async (manifestEntries) => {
  const manifest = manifestEntries.map((m) => {
    if (m.url === "dQw4w9WgXcQ") {
      m.url = "get-rick-rolled.mp4";
      m.revision = hashFile("static/get-rick-rolled.mp4");
    }
    return m;
  });
  return { manifest, warnings: [] };
};

injectManifest({
  // The path to the service worker file that will be read during the build process.
  swSrc: "app/sw.ts",
  // The path and filename of the service worker file that will be created by the build process.
  swDest: "dist/sw.js",
  // The string to find inside of the \`swSrc\` file. Once found, it will be replaced by the
  // generated precache manifest.
  injectionPoint: "self.__HI_MOM",
  // Whether the precache manifest should be set to \`undefined\`. Useful when you want it to only
  // check if the provided options are valid.
  disablePrecacheManifest: dev,
  // A list of entries to be precached, in addition to any entries that are generated as part of
  // the build configuration.
  additionalPrecacheEntries: [
    {
      url: "/~offline",
      revision: BUILD_ID,
    },
    {
      url: "/manifest.json",
      revision: hashFile("static/manifest.json"),
    },
  ],
  // Assets that match this will be assumed to be uniquely versioned via their URL, and exempted
  // from the normal HTTP cache-busting that's done when populating the precache.
  // NOTE: THE SERWIST TEAM IS NOT THAT GOOD AT REGEXPS. JUST KNOW THAT.
  dontCacheBustURLsMatching: /^dist\\/static\\/([a-zA-Z0-9]+)\\.([a-z0-9]+)\\.(css|js)$/,
  // One or more functions which will be applied sequentially against the generated manifest.
  manifestTransforms: [manifestTransform],
  // Determines the maximum size of files that will be precached.
  maximumFileSizeToCacheInBytes: 7355608,
  modifyURLPrefix: {
    // hi-mom/index.GdhNyhN1.js -> index.GdhNyhN1.js
    "hi-mom/": "",
  },
  // The local directory you wish to match \`globPatterns\` against.
  globDirectory: "dist/static",
  // Determines whether or not symlinks are followed when generating the precache manifest.
  globFollow: false,
  // A set of patterns matching files to always exclude when generating the precache manifest.
  globIgnores: ["**\\/node_modules\\/**\\/*"],
  // Files matching any of these patterns will be included in the precache manifest.
  globPatterns: [\"**\/*.{js,css,html,png,webmanifest,json}\"],
  // If true, an error reading a directory when generating a precache manifest will cause the
  // build to fail. If false, the problematic directory will be skipped.
  globStrict: false,
  // A map from URLs whose content is server-side rendered to either unique keys or sets of glob
  // patterns that should match the files used to render said content.
  templatedURLs: {
    "/legacy-home": ["legacy/home/*.html"],
  },
  // Other options...
  // See http://serwist.pages.dev/docs/build/configuring
});`,
          lang: "typescript",
        },
      },
      { idPrefix: "customizing", useTwoslash: false },
    ),
    interoperating: highlightCode(
      locals.highlighter,
      {
        "sw.ts": {
          code: `import type { PrecacheEntry, SerwistGlobalConfig } from "serwist";
import { Serwist } from "serwist";
import { BackgroundSyncQueue } from "serwist/plugins";
import { defaultCache } from "@serwist/vite/worker";

declare global {
  interface WorkerGlobalScope extends SerwistGlobalConfig {
    __SW_MANIFEST: (PrecacheEntry | string)[] | undefined;
  }
}

declare const self: ServiceWorkerGlobalScope;

self.skipWaiting();

self.addEventListener("activate", () => self.clients.claim());

const queue = new BackgroundSyncQueue("myQueueName");

const serwist = new Serwist({
  precacheEntries: self.__SW_MANIFEST,
  precacheOptions: {
    cleanupOutdatedCaches: true,
    concurrency: 10,
    ignoreURLParametersMatching: [],
  },
  skipWaiting: false,
  clientsClaim: false,
  navigationPreload: false,
  disableDevLogs: true,
  runtimeCaching: defaultCache,
});

self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);
  // For "/legacy-post" with the method "POST", this simply makes a network request,
  // but if that fails due to a network problem, the request is added to the Background
  // Synchronization Queue and will be retried later.
  if (event.request.method === "POST" && url.origin === location.origin && url.pathname === "/legacy-post") {
    const backgroundSync = async () => {
      try {
        const response = await fetch(event.request.clone());
        return response;
      } catch (error) {
        await queue.pushRequest({ request: event.request });
        return Response.error();
      }
    };
    event.respondWith(backgroundSync());
  }
});

serwist.addEventListeners();`,
          lang: "typescript",
        },
      },
      { idPrefix: "interoperating", useTwoslash: false },
    ),
  },
});
