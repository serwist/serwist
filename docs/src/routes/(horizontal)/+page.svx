---
layout: false
---
<script>
  import Code from "$components/Code.svelte";
  import Tabs from "$components/Tabs.svelte";
  import Tab from "$components/Tab.svelte";
  import { clsx } from "$lib/clsx";

  const { data } = $props();
</script>

<div
  class={clsx(
    "flex w-full flex-col gap-8 self-stretch bg-white px-8 py-6 text-black md:gap-24 md:p-24 dark:bg-black dark:text-white",
    "[&>div]:flex [&>div]:w-full [&>div]:max-w-screen-lg [&>div]:flex-col [&>div]:gap-6 [&>div]:md:self-center"
  )}
>
  <div class="py-24 md:py-0">
    <h1 class="text-6xl font-semibold tracking-tight">Serwist.</h1>
    <h2 class="text-4xl font-semibold tracking-tight text-comment">A Swiss Army knife for service workers.</h2>
    <Code showIcon>npm install -D serwist @serwist/build</Code>
  </div>
  <div>
    <h2 class="text-4xl font-semibold tracking-tight">
      Dead simple. <span class="text-comment">You need as much as ten lines of code to get started.</span>
    </h2>
    <Tabs id="getting-started" tabs={[["sw.ts", "sw-ts"], ["build.ts", "build-ts"]]}>
      <Tab id="sw-ts">

```ts
import { Serwist } from "serwist";

const serwist = new Serwist({
  precacheEntries: self.__SW_MANIFEST,
  skipWaiting: true,
  clientsClaim: true,
});

serwist.addEventListeners();
```

      </Tab>
      <Tab id="build-ts">

```ts
import { injectManifest } from "@serwist/build";

injectManifest({
  swSrc: "app/sw.ts",
  swDest: "dist/sw.js",
  globDirectory: "dist/static",
});
```

      </Tab>
    </Tabs>
  </div>
  <div>
    <h2 class="text-4xl font-semibold tracking-tight">
      Customizable. <span class="text-comment">Just do it your way.</span>
    </h2>
    <Tabs id="customizing" tabs={[["sw.ts", "sw-ts"], ["build.ts", "build-ts"]]}>
      <Tab id="sw-ts">

```ts
import type { PrecacheEntry, SerwistGlobalConfig } from "serwist";
import { Serwist } from "serwist";
import { defaultCache } from "@serwist/vite/worker";

declare global {
  interface WorkerGlobalScope extends SerwistGlobalConfig {
    // Change this attribute's name to your \`injectionPoint\`.
    // \`injectionPoint\` is an InjectManifest option.
    // See https://serwist.pages.dev/docs/build/configuring
    __SW_MANIFEST: (PrecacheEntry | string)[] | undefined;
  }
}

declare const self: ServiceWorkerGlobalScope;

const serwist = new Serwist({
  // A list of URLs that should be cached. Usually, you don't generate
  // this list yourself; rather, you'd rely on a Serwist build tool/your framework
  // to do it for you. In this example, it is generated by \`@serwist/vite\`.
  precacheEntries: self.__SW_MANIFEST,
  // Options to customize how Serwist precaches the URLs.
  precacheOptions: {
    // Whether outdated caches should be removed.
    cleanupOutdatedCaches: true,
    concurrency: 10,
    ignoreURLParametersMatching: [],
  },
  // Whether the service worker should skip waiting and become the active one.
  skipWaiting: true,
  // Whether the service worker should claim any currently available clients.
  clientsClaim: true,
  // Whether navigation preloading should be used.
  navigationPreload: false,
  // Whether Serwist should log in development mode.
  disableDevLogs: true,
  // A list of runtime caching entries. When a request is made and its URL match
  // any of the entries, the response to it will be cached according to the matching
  // entry's \`handler\`. This does not apply to precached URLs.
  runtimeCaching: defaultCache,
  // Other options...
  // See https://serwist.pages.dev/docs/serwist/core/serwist
});

serwist.addEventListeners();
```

      </Tab>
      <Tab id="build-ts">

```ts
import { injectManifest, type ManifestTransform } from "@serwist/build";

/**
 * A custom build ID.
 */
declare const BUILD_ID: string;
/**
 * Hash a file based on its contents.
 */
declare const hashFile: (file: string) => string;
/**
 * Whether the server is currently in development mode.
 */
declare const dev: boolean;

const manifestTransform: ManifestTransform = async (manifestEntries) => {
  const manifest = manifestEntries.map((m) => {
    if (m.url === "dQw4w9WgXcQ") {
      m.url = "get-rick-rolled.mp4";
      m.revision = hashFile("static/get-rick-rolled.mp4");
    }
    return m;
  });
  return { manifest, warnings: [] };
};

injectManifest({
  // The path to the service worker file that will be read during the build process.
  swSrc: "app/sw.ts",
  // The path and filename of the service worker file that will be created by the build process.
  swDest: "dist/sw.js",
  // The string to find inside of the \`swSrc\` file. Once found, it will be replaced by the
  // generated precache manifest.
  injectionPoint: "self.__HI_MOM",
  // Whether the precache manifest should be set to \`undefined\`. Useful when you want it to only
  // check if the provided options are valid.
  disablePrecacheManifest: dev,
  // A list of entries to be precached, in addition to any entries that are generated as part of
  // the build configuration.
  additionalPrecacheEntries: [
    {
      url: "/~offline",
      revision: BUILD_ID,
    },
    {
      url: "/manifest.json",
      revision: hashFile("static/manifest.json"),
    },
  ],
  // Assets that match this will be assumed to be uniquely versioned via their URL, and exempted
  // from the normal HTTP cache-busting that's done when populating the precache.
  // NOTE: THE SERWIST TEAM IS NOT THAT GOOD AT REGEXPS. JUST KNOW THAT.
  dontCacheBustURLsMatching: /^dist\\/static\\/([a-zA-Z0-9]+)\\.([a-z0-9]+)\\.(css|js)$/,
  // One or more functions which will be applied sequentially against the generated manifest.
  manifestTransforms: [manifestTransform],
  // Determines the maximum size of files that will be precached.
  maximumFileSizeToCacheInBytes: 7355608,
  modifyURLPrefix: {
    // hi-mom/index.GdhNyhN1.js -> index.GdhNyhN1.js
    "hi-mom/": "",
  },
  // The local directory you wish to match \`globPatterns\` against.
  globDirectory: "dist/static",
  // Determines whether or not symlinks are followed when generating the precache manifest.
  globFollow: false,
  // A set of patterns matching files to always exclude when generating the precache manifest.
  globIgnores: ["**\\/node_modules\\/**\\/*"],
  // Files matching any of these patterns will be included in the precache manifest.
  globPatterns: [\"**\/*.{js,css,html,png,webmanifest,json}\"],
  // If true, an error reading a directory when generating a precache manifest will cause the
  // build to fail. If false, the problematic directory will be skipped.
  globStrict: false,
  // A map from URLs whose content is server-side rendered to either unique keys or sets of glob
  // patterns that should match the files used to render said content.
  templatedURLs: {
    "/legacy-home": ["legacy/home/*.html"],
  },
  // Other options...
  // See http://serwist.pages.dev/docs/build/configuring
});
```

      </Tab>
    </Tabs>
  </div>
  <div>
    <h2 class="text-4xl font-semibold tracking-tight">
      Interoperable. <span class="text-comment">The Serwist API. The Service Worker API. It doesn't matter.</span>
    </h2>
    <Tabs id="interoperating" tabs={[["sw.ts", "sw-ts"]]}>
      <Tab id="sw-ts">

```ts
import type { PrecacheEntry, SerwistGlobalConfig } from "serwist";
import { BackgroundSyncQueue, Serwist } from "serwist";
import { defaultCache } from "@serwist/vite/worker";

declare global {
  interface WorkerGlobalScope extends SerwistGlobalConfig {
    __SW_MANIFEST: (PrecacheEntry | string)[] | undefined;
  }
}

declare const self: ServiceWorkerGlobalScope;

self.skipWaiting();

self.addEventListener("activate", () => self.clients.claim());

const queue = new BackgroundSyncQueue("myQueueName");

const serwist = new Serwist({
  precacheEntries: self.__SW_MANIFEST,
  precacheOptions: {
    cleanupOutdatedCaches: true,
    concurrency: 10,
    ignoreURLParametersMatching: [],
  },
  skipWaiting: false,
  clientsClaim: false,
  navigationPreload: false,
  disableDevLogs: true,
  runtimeCaching: defaultCache,
});

self.addEventListener("fetch", (event) => {
  const url = new URL(event.request.url);
  // For "/legacy-post" with the method "POST", this simply makes a network request,
  // but if that fails due to a network problem, the request is added to the background
  // synchronization queue and will be retried later.
  if (event.request.method === "POST" && url.origin === location.origin && url.pathname === "/legacy-post") {
    const backgroundSync = async () => {
      try {
        const response = await fetch(event.request.clone());
        return response;
      } catch (error) {
        await queue.pushRequest({ request: event.request });
        return Response.error();
      }
    };
    event.respondWith(backgroundSync());
  }
});

serwist.addEventListeners();
```

      </Tab>
    </Tabs>
  </div>
</div>
